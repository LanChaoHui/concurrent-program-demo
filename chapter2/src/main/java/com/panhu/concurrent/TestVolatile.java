package com.panhu.concurrent;

/**
 * 一、volatile 简介
 * <p>
 * volatile 是java 提供的一种轻量级的同步机制。 Java 语言包含两种内在的同步机制：同步块（或方法）和volatile变量
 * ，相比于 synchronize (synchronize 通常称为重量级锁)，volatile 更轻量级，因为它不会引起线程上下文的切换和调度。但是
 * volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。
 * <p>
 * 二、3个概念
 * <p>
 * 1. 原子性
 * <p>
 * 定义：即一个操作或者多个操作要么全部执行并且执行过程中不会被任何因素打断，要么都不执行。
 * <p>
 * 原子性是拒绝多线程操作的，不论是多核还是单核，具有原子性的量，同一时刻只能一个线程来对它进行操作，简而言之，在整个操作过程中
 * 不会被线程调度器中断的操作，都可以认为是原子性。例如a=1是原子性操作，但是a++ 和a+=1就不是原子性操作。Java 中的原子性操作包括：
 * <p>
 * (1) 基本类型的读取和赋值操作，且赋值必须是赋值给变量，变量之间的相互赋值不是原子性。
 * (2) 所有引用reference的赋值操作
 * (3) java.concurrent.Atomic.* 包所有类的操作
 * <p>
 * 2. 可见性
 * 定义： 指当多线程访问一个变量是，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
 * <p>
 * 在多线程环境下，一个线程对共享变量的操作其他线程是不可见的。Java 提供了volatile 来保证可见性，当一个变量被volatile修饰后
 * ，表示线程本地内存无效，当一个线程修改共享变量后他会立即被更新到内存中，其他线程读取共享变量时，会直接从主内存中读取，当然
 * synchronize 和 Lock 都可以保证可见性。synchronized和Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放前
 * 会将变量的修改刷新到主内存中。因此可以保证可见性。
 * <p>
 * 3. 有序性
 * <p>
 * 定义：即程序执行顺序安装代码的先后顺序执行
 * <p>
 * Java 内存模型中有序性可以总结为：如果在本现场内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是
 * 无序的。
 * <p>
 * 在Java内存模型中，为了效率是允许编译器和处理器对指令重排序，当然重排序不会影响单线程的运行结果，但是对线程会有影响。
 * Java 提供volatile 来保证一定的有序性。另外，可以通过synchronized和Lock 保证每个时刻是一个线程执行同步代码，相当于是让线程
 * 顺序执行同步代码，自然就保证有序性。
 * <p>
 * 三、锁的互斥和可见性
 * <p>
 * 锁提供了两种主要特性：互斥和可见性
 * <p>
 * （1） 互斥即一次只允许一个线程持有某个特定的锁，一个就只有一个线程能够使用该共享数据。
 * （2） 可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后或该锁的另一个线程是可见的。也即当一条线程修改共享变量的值，
 * 新值对于其他线程来说是可以立即得知的。如果没有同步机制提供的这种可见性，线程看到的共享变量可能是修改的之前或不一致的值，这将引起许多严重问题。
 * 要使用 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：
 * a. 对变量的写操作不依赖于当前值
 * b. 该变量没有包含在具有其他变量的不变式中。
 * <p>
 * 实际上，这些条件表明，可以被写入volatile 变量的这些有效值独立独立于任何程序的状态，包括变量的当前状态。事实上就是保证
 * 操作是原子性操作，才能保证使用volatile 关键字在并发时能够正确执行。
 * <p>
 * 四、Java 的内存模型JVM 以及共享变量的可见性
 * <p>
 * JMM 决定一个线程对共享变量的写入如何对另一线程可见，JMM定义了线程和主内存之间抽象关系：共享变量存储在主内存(Main Memory) 中
 * ，每个线程都有一个私有内存(Local Memory) ，本地内存保存了被该线程使用到的住内存的副本拷贝，线程对变量的所有操作都必须
 * 在工作内存中进行，而不能直接读主内存中的变量。
 * <p>
 * 对于普通的共享变量来讲，线程A将其修改为某个值发生在现场A的本地内存中，此时还未同步到主内存中去；而现场B已经缓存了该变量的旧值，所以
 * 就导致了共享变量值不一致。解决这种共享变量在多线程中不可见性问题，比较粗暴的方式自然就是加锁，但是此处使用synchronize或者
 * Lock 这些方式太重量级，比较合理的方式其实就是volatile 。
 * <p>
 * 需要注意的是，JMM 是一个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念并不一定就真实的对应cup缓存和物理内存
 * <p>
 * 五、volatile 变量的特性
 * <p>
 * 1. 保证可见性，不保证原子性
 * <p>
 * （1） 当写一个volatile 变量时，JMM 会把该线程本地中的变量强制刷新到主内存中去。
 * （2） 这个写会操作会导致其他线程中的volatile 变量缓存无效。
 * <p>
 * 2. 禁止指令重排
 * 重排序是指编译器和处理器为了优化程序性能二队指令进行排序的一种手段。重排序需要遵守一定规则
 * <p>
 * （1） 重排序操作不会对存在数据依赖关系的操作进行重排序
 * 比如： a=1;b=a；这个指令，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。
 * （2） 重排序是为了优化性能，但是不管怎么排序，单线程下程序执行结果不能被改变
 * 比如：a=1;b=2;c=a+b;这三个操作，第一步（a=1）和第二部（b=2） 由于不存在数据依赖关系，所以可能会发生重排序，但是c=a+b这个操作是
 * 不会被重新排序的，因为需要保证最终的结果是c=a+b=3;
 * <p>
 * 重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果，下例中的1和2由于不存在数据依赖，
 * 关系，则有可能会被重排序，先执行status=true，再执行a=2.此时线程B会顺利到达4处，而线程A中a=2这个操作还未被执行，所以
 * b=a+1的结果可能依然等于2
 */
public class TestVolatile {
    static class Child{
        static volatile int A=0;
        public static void setA(int a){
            A=a;
        }
    }

    public static void main(String[] args) {
        Child.setA(1);
        new Thread(new Runnable() {
            @Override
            public void run() {
                // 保证先让主线程读到A的值后再写入
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                Child.setA(3);
                System.out.println("child-thread: read variable A-"+Child.A);
            }
        }).start();
        // 此时的A 已经被子线程修改
        System.out.println("main-thread:read variable A - "+Child.A);
    }
}
